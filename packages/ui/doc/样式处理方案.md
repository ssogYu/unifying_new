# 样式处理方案

## 概述

@unifying/ui 组件库采用**按需引入样式**的设计理念，每个组件内部自动导入自己的样式文件，样式代码内联到 JavaScript 文件中，使用时无需手动引入样式，实现真正的按需加载。

## 设计理念

### 核心原则

1. **样式内联**：样式代码内联到 JavaScript 文件中，随组件一起加载
2. **按需加载**：只加载使用到的组件样式，未使用的样式会被 Tree-shaking 移除
3. **自动注入**：使用 `style-loader` 自动将样式注入到 DOM 中
4. **零配置**：使用组件时无需关心样式文件的引入

### 为什么选择内联样式

对于组件库而言，内联样式相比提取 CSS 文件有以下优势：

| 特性         | 内联样式          | 提取 CSS 文件         |
| ------------ | ----------------- | --------------------- |
| 按需加载     | ✅ 自动实现       | ❌ 需要手动引入       |
| Tree-shaking | ✅ 完全支持       | ⚠️ 部分支持           |
| 使用复杂度   | ✅ 零配置         | ❌ 需要额外配置       |
| 缓存策略     | ✅ 组件级缓存     | ✅ 文件级缓存         |
| 包体积       | ✅ 只包含使用样式 | ⚠️ 可能包含未使用样式 |

## Webpack 配置详解

### 1. 样式加载器配置

```javascript
// webpack.config.cjs

const getStyleLoaders = () => {
  // 基础的样式加载器配置
  const baseLoaders = [
    // css-loader：解析 CSS 文件中的 @import 和 url() 语句
    // 将 CSS 转换为 JavaScript 模块，使其能被 webpack 处理
    'css-loader',

    {
      // postcss-loader：使用 PostCSS 处理 CSS
      // PostCSS 是一个用 JavaScript 转换 CSS 的工具
      loader: 'postcss-loader',
      options: {
        postcssOptions: {
          // PostCSS 插件列表
          // 可以添加 autoprefixer、cssnano 等插件
          plugins: [],
        },
      },
    },
  ];

  // 对于组件库，始终使用 style-loader 将样式注入到 DOM 中
  // 这样可以实现按需引入样式，样式会随着组件一起加载
  return ['style-loader', ...baseLoaders];
};
```

### 2. 样式处理规则

```javascript
// webpack.config.cjs

module: {
  rules: [
    // CSS 文件处理规则
    {
      test: /\.css$/,
      use: getStyleLoaders(),
    },

    // SCSS 文件处理规则
    {
      test: /\.scss$/,
      use: [...getStyleLoaders(), 'sass-loader'],
    },

    // LESS 文件处理规则
    {
      test: /\.less$/,
      use: [...getStyleLoaders(), 'less-loader'],
    },
  ],
}
```

### 3. 样式处理流程

```
源样式文件 (.less/.scss/.css)
    ↓
预处理器 (less-loader/sass-loader)
    ↓
PostCSS 处理 (postcss-loader)
    ↓
CSS 解析 (css-loader)
    ↓
样式注入 (style-loader)
    ↓
内联到 JavaScript 模块
    ↓
运行时自动注入到 DOM
```

### 4. 为什么不使用 MiniCssExtractPlugin

对于组件库，我们选择不使用 `MiniCssExtractPlugin`，原因如下：

**MiniCssExtractPlugin 的问题**：

- 样式被提取到单独的 CSS 文件
- 使用组件时需要手动引入 CSS 文件
- 无法实现真正的按需加载
- 增加使用复杂度

**style-loader 的优势**：

- 样式内联到 JS 文件中
- 使用组件时样式自动加载
- 完全支持 Tree-shaking
- 零配置使用

### 5. 生产环境优化

虽然不提取 CSS 文件，但我们仍然进行了以下优化：

```javascript
// webpack.config.cjs - 生产环境配置

if (isProduction) {
  // 启用代码压缩
  baseConfig.optimization = {
    minimize: true,

    // 使用 TerserPlugin 压缩 JavaScript 代码
    minimizer: [
      new TerserPlugin({
        parallel: true, // 并行压缩
        terserOptions: {
          compress: {
            drop_console: true, // 移除 console
            drop_debugger: true, // 移除 debugger
            pure_funcs: ['console.log'],
          },
          format: {
            comments: false, // 移除注释
          },
        },
        extractComments: false,
      }),
    ],
  };
}
```

样式代码会被 TerserPlugin 压缩，减小包体积。

## 组件实现规范

### 1. 组件结构

每个组件应该遵循以下结构：

```
components/
└── ComponentName/
    ├── index.tsx       # 组件实现
    ├── styles.less     # 样式文件
    └── index.d.ts     # 类型定义（可选）
```

### 2. 组件实现示例

```tsx
// components/Button/index.tsx
import React from 'react';
import classNames from 'classnames';

// ✅ 在组件内部导入样式文件
import './styles.less';

export interface ButtonProps {
  type?: 'primary' | 'secondary';
  size?: 'small' | 'medium' | 'large';
  children?: React.ReactNode;
  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
}

const Button: React.FC<ButtonProps> = ({
  type = 'primary',
  size = 'medium',
  children,
  onClick,
  className,
  ...restProps
}) => {
  const classes = classNames(
    'un-btn', // 基础类名
    `un-btn-${type}`, // 类型修饰符
    `un-btn-${size}`, // 尺寸修饰符
    className
  );

  return (
    <button className={classes} onClick={onClick} {...restProps}>
      {children}
    </button>
  );
};

export default Button;
```

### 3. 样式文件示例

```less
// components/Button/styles.less

// ✅ 使用 BEM 命名规范，避免样式冲突
.un-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  cursor: pointer;
  border: 1px solid transparent;
  transition: all 0.3s;

  // 尺寸变体
  &--small {
    height: 24px;
    padding: 0 7px;
    font-size: 12px;
  }

  &--medium {
    height: 32px;
    padding: 0 15px;
    font-size: 14px;
  }

  &--large {
    height: 40px;
    padding: 0 23px;
    font-size: 16px;
  }

  // 类型变体
  &--primary {
    background: #1677ff;
    border-color: #1677ff;
    color: #fff;

    &:hover {
      background: #4096ff;
      border-color: #4096ff;
    }
  }

  &--secondary {
    background: #fff;
    border-color: #d9d9d9;
    color: rgba(0, 0, 0, 0.88);

    &:hover {
      border-color: #1677ff;
      color: #1677ff;
    }
  }

  // 状态修饰符
  &--disabled {
    cursor: not-allowed;
    opacity: 0.6;
  }

  // 子元素
  &__icon {
    margin-right: 8px;
  }

  &__content {
    display: inline-block;
  }
}
```

### 4. 入口文件导出

```tsx
// src/index.ts

// ✅ 只导出组件，不导入样式
export { default as Button } from './components/Button';
export type { ButtonProps } from './components/Button';

// ❌ 不要这样做！
// import './components/Button/styles.less';
```

## 使用方式

### 方式一：从主入口导入（推荐）

最简单的方式，从主入口导入组件：

```tsx
import { Button } from '@unifying/ui';

function App() {
  return (
    <div>
      <Button type="primary">主要按钮</Button>
      <Button type="secondary">次要按钮</Button>
      <Button type="danger">危险按钮</Button>
    </div>
  );
}
```

**特点**：

- ✅ 样式自动加载
- ✅ 支持 Tree-shaking
- ✅ 零配置使用

### 方式二：导入多个组件

导入多个组件时，只会加载使用到的组件样式：

```tsx
import { Button, Input, Select, DatePicker } from '@unifying/ui';

function App() {
  return (
    <div>
      <Button type="primary">提交</Button>
      <Input placeholder="请输入内容" />
      <Select options={[{ label: '选项1', value: '1' }]} />
      <DatePicker />
    </div>
  );
}
```

**打包结果**：

- ✅ 只包含 Button、Input、Select、DatePicker 的样式
- ✅ 未使用的组件样式会被 Tree-shaking 移除

### 方式三：深度导入（高级用法）

如果只想导入特定组件，可以使用深度导入：

```tsx
import Button from '@unifying/ui/es/components/Button';

function App() {
  return <Button type="primary">点击我</Button>;
}
```

**适用场景**：

- 只使用单个组件
- 需要更细粒度的控制
- 优化打包体积

## 构建产物

### 文件结构

构建后会在 `dist` 目录生成以下文件：

```
dist/
├── components/              # 组件类型定义
│   └── Button/
│       └── index.d.ts
├── index.cjs.js           # CommonJS 格式（包含样式）
├── index.esm.js           # ES Module 格式（包含样式）
├── index.umd.js           # UMD 格式（包含样式）
└── *.d.ts               # 类型定义文件
```

### 样式内联验证

可以通过以下方式验证样式是否内联到 JS 文件中：

```bash
# 检查 JS 文件中是否包含样式类名
grep -o "un-btn" dist/index.esm.js
```

如果输出包含样式类名，说明样式已成功内联。

### 包体积分析

使用构建分析工具查看包体积：

```bash
# 生成构建分析报告
ANALYZE=true pnpm build

# 查看报告
open dist/bundle-report.html
```

## 优势详解

### 1. 真正的按需加载

只加载使用到的组件样式，未使用的样式会被完全移除：

```tsx
// 只使用 Button 组件
import { Button } from '@unifying/ui';

// 打包后只包含 Button 的样式（约 15KB）
// 不包含其他组件的样式
```

### 2. 完全的 Tree-shaking 支持

Webpack 可以精确地移除未使用的代码和样式：

```tsx
// 导入但未使用
import { Button, Input, Select } from '@unifying/ui';

function App() {
  return <Button type="primary">点击</Button>;
}

// 打包后只包含 Button 的代码和样式
// Input 和 Select 会被完全移除
```

### 3. 零配置使用

使用组件时无需关心样式文件的引入：

```tsx
// ✅ 简单直接
import { Button } from '@unifying/ui';

// ❌ 不需要这样做
import { Button } from '@unifying/ui';
import '@unifying/ui/dist/styles.css';
```

### 4. 更好的缓存策略

每个组件的样式独立，修改一个组件的样式不会影响其他组件的缓存：

```
用户访问页面 → 加载 Button 组件和样式（缓存）
开发者修改 Button 样式 → 重新构建
用户刷新页面 → 只重新加载 Button 的样式（其他组件缓存不变）
```

### 5. 灵活的样式控制

可以针对不同组件使用不同的样式预处理器：

```
components/
├── Button/
│   └── styles.less      # 使用 Less
├── Input/
│   └── styles.scss      # 使用 Sass
└── Select/
    └── styles.css       # 使用 CSS
```

## 注意事项

### 1. 不要在入口文件全局导入样式

❌ **错误做法**：

```tsx
// src/index.ts
import { Button } from './components/Button';
import './components/Button/styles.less'; // ❌ 不要这样做！

export { Button };
```

**问题**：

- 会导致样式被全局加载
- 无法实现按需加载
- 增加不必要的包体积

✅ **正确做法**：

```tsx
// src/index.ts
export { Button } from './components/Button';
```

### 2. 确保样式文件路径正确

组件导入样式时，确保使用相对路径：

```tsx
// ✅ 正确：使用相对路径
import './styles.less';

// ❌ 错误：不要使用绝对路径
import '/components/Button/styles.less';

// ❌ 错误：不要使用别名路径
import '@/components/Button/styles.less';
```

### 3. 样式文件命名规范

建议使用统一的样式文件命名：

- `styles.less` - Less 样式文件
- `styles.scss` - Sass 样式文件
- `styles.css` - CSS 样式文件

**不推荐**：

- `button.less` - 与组件名重复
- `style.less` - 单数形式
- `Button.less` - 大写开头

### 4. 避免样式冲突

使用 BEM 命名规范避免样式冲突：

```less
// ✅ 使用 BEM 命名
.un-btn {
  // Block
  &__icon {
    // Element
  }
  &__content {
    // Element
  }
  &--primary {
    // Modifier
  }
  &--disabled {
    // Modifier
  }
}

// ❌ 不推荐：使用简单类名
.button {
}
.primary {
}
.disabled {
}
```

### 5. 样式作用域限制

避免使用全局样式选择器：

```less
// ✅ 推荐：使用作用域限制
.un-btn {
  color: #fff;
  background: #1677ff;
}

// ❌ 不推荐：使用全局选择器
button {
  color: #fff;
  background: #1677ff;
}
```

## 在应用中使用

### 方式一：直接使用（推荐）

```tsx
import { Button } from '@unifying/ui';

function App() {
  return <Button type="primary">点击我</Button>;
}
```

### 方式二：提取 CSS 文件（可选）

如果需要在应用中提取 CSS 文件（为了更好的缓存策略），可以在应用的 webpack 配置中配置：

```javascript
// 应用的 webpack.config.js

const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader'],
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({
      filename: 'css/[name].[contenthash:8].css',
    }),
  ],
};
```

**注意**：组件库的样式会被提取到应用的 CSS 文件中，不影响使用。

### 方式三：自定义样式覆盖

如果需要覆盖组件的默认样式，可以使用更高优先级的选择器：

```tsx
import { Button } from '@unifying/ui';
import './custom-styles.css';

function App() {
  return (
    <Button type="primary" className="my-custom-button">
      点击我
    </Button>
  );
}
```

```css
/* custom-styles.css */
.my-custom-button {
  background: #ff4d4f !important;
  border-radius: 20px !important;
}
```

## 故障排查

### 问题：样式未生效

**可能原因**：

1. 组件未正确导入样式文件
2. Webpack 配置未正确处理样式文件
3. 样式文件路径错误
4. 浏览器缓存问题

**解决方法**：

1. 检查组件是否导入了样式文件：

```tsx
// components/Button/index.tsx
import './styles.less'; // ✅ 确保有这一行
```

2. 检查 Webpack 配置是否包含样式 loader：

```javascript
// webpack.config.cjs
{
  test: /\.less$/,
  use: ['style-loader', 'css-loader', 'postcss-loader', 'less-loader'],
}
```

3. 检查浏览器控制台是否有错误

4. 清除浏览器缓存并刷新页面

### 问题：样式覆盖不生效

**可能原因**：

1. CSS 选择器优先级不够
2. 样式加载顺序问题
3. 组件类名冲突

**解决方法**：

1. 使用更高优先级的选择器

```css
/* ✅ 使用更高优先级 */
.my-custom-button.un-btn {
  background: #ff4d4f;
}

/* ✅ 使用 !important（不推荐） */
.my-custom-button {
  background: #ff4d4f !important;
}
```

2. 确保自定义样式在组件样式之后加载

```tsx
// 先导入组件
import { Button } from '@unifying/ui';

// 后导入自定义样式
import './custom-styles.css';
```

### 问题：包体积过大

**可能原因**：

1. 导入了未使用的组件
2. 样式代码未压缩
3. 依赖包体积过大

**解决方法**：

1. 使用构建分析工具

```bash
# 生成构建分析报告
ANALYZE=true pnpm build
```

2. 检查是否有未使用的导入

```tsx
// ❌ 导入但未使用
import { Button, Input, Select, DatePicker } from '@unifying/ui';

function App() {
  return <Button type="primary">点击</Button>;
}

// ✅ 只导入使用的组件
import { Button } from '@unifying/ui';
```

3. 检查依赖包

```bash
# 查看依赖包大小
pnpm why classnames
```

### 问题：开发环境样式不更新

**可能原因**：

1. 样式文件未正确监听
2. Webpack 缓存问题
3. HMR 未正确配置

**解决方法**：

1. 清除 Webpack 缓存

```bash
pnpm clean
pnpm dev
```

2. 检查 webpack-dev-server 配置

```javascript
// webpack.config.cjs
devServer: {
  hot: true, // ✅ 启用热更新
  client: {
    progress: true, // ✅ 显示构建进度
  },
}
```

## 最佳实践

### 1. 组件开发规范

- ✅ 始终在组件内部导入样式
- ✅ 使用 BEM 命名规范
- ✅ 避免全局样式污染
- ✅ 使用相对路径导入样式
- ✅ 统一样式文件命名

### 2. 样式编写规范

- ✅ 使用 Less/Sass 预处理器
- ✅ 使用嵌套语法
- ✅ 使用变量和混合（mixin）
- ✅ 避免硬编码颜色和尺寸
- ✅ 使用语义化的类名

### 3. 性能优化

- ✅ 定期检查打包体积
- ✅ 使用构建分析工具
- ✅ 移除未使用的代码和样式
- ✅ 压缩样式代码
- ✅ 启用持久化缓存

### 4. 使用建议

- ✅ 从主入口导入组件
- ✅ 只导入使用的组件
- ✅ 使用深度导入优化包体积
- ✅ 避免全局导入样式
- ✅ 使用 CSS Modules 或 BEM 避免冲突

## 相关资源

- [Webpack 官方文档](https://webpack.js.org/)
- [style-loader 文档](https://webpack.js.org/loaders/style-loader/)
- [css-loader 文档](https://webpack.js.org/loaders/css-loader/)
- [less-loader 文档](https://webpack.js.org/loaders/less-loader/)
- [sass-loader 文档](https://webpack.js.org/loaders/sass-loader/)
- [postcss-loader 文档](https://webpack.js.org/loaders/postcss-loader/)
- [BEM 命名规范](http://getbem.com/)
- [Less 官方文档](http://lesscss.org/)
- [Sass 官方文档](https://sass-lang.com/)
